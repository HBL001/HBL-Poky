Upstream-Status: Inappropriate [oe specific]

From 979e6d183e8e0fae86e3de7ea9a999df3efa359f Mon Sep 17 00:00:00 2001
From: customer <customer@company.com>
Date: Wed, 23 Apr 2025 23:23:37 +0100
Subject: [PATCH] eeprom-delete

---
 board/ti/common/board_detect.c | 124 ++++-----------------------------
 1 file changed, 13 insertions(+), 111 deletions(-)

diff --git a/board/ti/common/board_detect.c b/board/ti/common/board_detect.c
index 0ec6d1aaf4c..39debb9d8f1 100644
--- a/board/ti/common/board_detect.c
+++ b/board/ti/common/board_detect.c
@@ -87,119 +87,21 @@ __weak void gpi2c_init(void)
 static int __maybe_unused ti_i2c_eeprom_get(int bus_addr, int dev_addr,
 					    u32 header, u32 size, uint8_t *ep)
 {
-	int rc;
-	uint8_t offset_test;
-	bool one_byte_addressing = true;
-
-#if CONFIG_IS_ENABLED(DM_I2C)
-	struct udevice *dev;
-	struct udevice *bus;
-
-	rc = uclass_get_device_by_seq(UCLASS_I2C, bus_addr, &bus);
-	if (rc)
-		return rc;
-	rc = dm_i2c_probe(bus, dev_addr, 0, &dev);
-	if (rc)
-		return rc;
-
-	/*
-	 * Read the header first then only read the other contents.
-	 */
-	rc = i2c_set_chip_offset_len(dev, 1);
-	if (rc)
-		return rc;
-
-	/*
-	 * Skip checking result here since this could be a valid i2c read fail
-	 * on some boards that use 2 byte addressing.
-	 * We must allow for fall through to check the data if 2 byte
-	 * addressing works
-	 */
-	(void)dm_i2c_read(dev, 0, ep, size);
-
-	if (*((u32 *)ep) != header)
-		one_byte_addressing = false;
-
-	/*
-	 * Handle case of bad 2 byte eeproms that responds to 1 byte addressing
-	 * but gets stuck in const addressing when read requests are performed
-	 * on offsets. We perform an offset test to make sure it is not a 2 byte
-	 * eeprom that works with 1 byte addressing but just without an offset
-	 */
-
-	rc = dm_i2c_read(dev, 0x1, &offset_test, sizeof(offset_test));
-
-	if (*((u32 *)ep) != (header & 0xFF))
-		one_byte_addressing = false;
-
-	/* Corrupted data??? */
-	if (!one_byte_addressing) {
-		/*
-		 * read the eeprom header using i2c again, but use only a
-		 * 2 byte address (some newer boards need this..)
-		 */
-		rc = i2c_set_chip_offset_len(dev, 2);
-		if (rc)
-			return rc;
-
-		rc = dm_i2c_read(dev, 0, ep, size);
-		if (rc)
-			return rc;
-	}
-	if (*((u32 *)ep) != header)
-		return -1;
-#else
-	u32 byte;
-
-	gpi2c_init();
-	rc = ti_i2c_eeprom_init(bus_addr, dev_addr);
-	if (rc)
-		return rc;
-
-	/*
-	 * Read the header first then only read the other contents.
-	 */
-	byte = 1;
-
-	/*
-	 * Skip checking result here since this could be a valid i2c read fail
-	 * on some boards that use 2 byte addressing.
-	 * We must allow for fall through to check the data if 2 byte
-	 * addressing works
-	 */
-	(void)i2c_read(dev_addr, 0x0, byte, ep, size);
-
-	if (*((u32 *)ep) != header)
-		one_byte_addressing = false;
-
-	/*
-	 * Handle case of bad 2 byte eeproms that responds to 1 byte addressing
-	 * but gets stuck in const addressing when read requests are performed
-	 * on offsets. We perform an offset test to make sure it is not a 2 byte
-	 * eeprom that works with 1 byte addressing but just without an offset
-	 */
-
-	rc = i2c_read(dev_addr, 0x1, byte, &offset_test, sizeof(offset_test));
+	if(!ep || size < sizeof(struct ti_am_eeprom)) return -EINVAL;	   										// is ti_am_eeprom buffer too small or null ?	
+
+	memset(ep, 0, sizeof(struct ti_am_eeprom));  								// wipe the buffer
+	*(u32 *)(ep + offsetof(struct ti_am_eeprom, header)) = header;						// Header (u32 at offset 0)
+	strlcpy((char *)(ep + offsetof(struct ti_am_eeprom, name)), "A335BNLT",TI_EEPROM_HDR_NAME_LEN + 1);	// BOARD field
+	strlcpy((char *)(ep + offsetof(struct ti_am_eeprom, version)),"00C0",TI_EEPROM_HDR_REV_LEN + 1);	// VERSION field	
+	strlcpy((char *)(ep + offsetof(struct ti_am_eeprom, serial)),"0000",TI_EEPROM_HDR_SERIAL_LEN + 1);	// SERIAL field
+    	strlcpy((char *)(ep + offsetof(struct ti_am_eeprom, config)),"BBBC",TI_EEPROM_HDR_CONFIG_LEN + 1);	// CONFIG field
+	
+	memcpy(ep + offsetof(struct ti_am_eeprom, mac_addr[0]),(const u8[]){0x02,0x01,0x02,0x03,0x04,0x05},TI_EEPROM_HDR_ETH_ALEN);
+    	memcpy(ep + offsetof(struct ti_am_eeprom, mac_addr[1]),(const u8[]){0x02,0x01,0x02,0x03,0x04,0x06},TI_EEPROM_HDR_ETH_ALEN);
+    	return 0;
+}
 
-	if (*((u32 *)ep) != (header & 0xFF))
-		one_byte_addressing = false;
 
-	/* Corrupted data??? */
-	if (!one_byte_addressing) {
-		/*
-		 * read the eeprom header using i2c again, but use only a
-		 * 2 byte address (some newer boards need this..)
-		 */
-		byte = 2;
-		rc = i2c_read(dev_addr, 0x0, byte, ep, size);
-		if (rc)
-			return rc;
-	}
-	if (*((u32 *)ep) != header)
-		return -1;
-#endif
-	return 0;
-}
 
 int __maybe_unused ti_emmc_boardid_get(void)
 {
-- 
2.43.0

